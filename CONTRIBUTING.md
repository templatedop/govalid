# Contributing to govalid

Thank you for your interest in contributing to govalid! This document provides guidelines for contributing to the project, with a focus on implementing new validation markers.

## üöÄ Getting Started

### Prerequisites

- Go 1.24 or later
- Git
- golangci-lint for code quality checks

### Development Setup

1. Fork and clone the repository:
```bash
git clone https://github.com/yourusername/govalid.git
cd govalid
```

2. Install dependencies:
```bash
go mod download
```

3. Install the govalid binary:
```bash
go install ./cmd/govalid/
```

## üìù How to Add a New Validation Marker

### Overview

With our new automated system, adding a new marker is streamlined to just a few steps. The registry system automatically discovers and integrates new validators without manual switch statement updates.

### Step 1: Create a New Validator Using Scaffold

```bash
# Create a scaffold for your new validator and generate all registry files
make generate-validator MARKER=phoneNumber

# This:
# ‚úì Generates scaffold: internal/validator/rules/phonenumber.go
# ‚úì Updates internal/markers/markers_generated.go
# ‚úì Creates internal/validator/registry/initializers/phonenumber.go
# ‚úì Updates internal/validator/registry/initializers/all.go
# ‚úì Updates internal/analyzers/govalid/registry_init.go
```

### Step 2: Implement the Validator Logic

Edit the generated file `internal/validator/rules/phonenumber.go`:

```go
package rules

import (
    "fmt"
    "go/ast"
    "go/types"
    "strings"
    
    "github.com/gostaticanalysis/codegen"
    "github.com/sivchari/govalid/internal/validator"
)

type phonenumberValidator struct {
    pass       *codegen.Pass
    field      *ast.Field
    structName string
    pattern    string // Add any parameters your validator needs
}

var _ validator.Validator = (*phonenumberValidator)(nil)

const phonenumberKey = "%s-phonenumber"

func (v *phonenumberValidator) Validate() string {
    // Implement your validation logic
    // Return a Go expression that evaluates to true when validation FAILS
    return fmt.Sprintf(`!regexp.MustCompile(%q).MatchString(t.%s)`, v.pattern, v.FieldName())
}

func (v *phonenumberValidator) FieldName() string {
    return v.field.Names[0].Name
}

func (v *phonenumberValidator) Err() string {
    key := fmt.Sprintf(phonenumberKey, v.structName+v.FieldName())
    if validator.GeneratorMemory[key] {
        return ""
    }

    validator.GeneratorMemory[key] = true

	  const errTemplate = `
	  	// [@ERRVARIABLE] is returned when the [@FIELD] fails phonenumber validation.
	  	[@ERRVARIABLE] = govaliderrors.ValidationError{Reason:"field [@PATH] must be a valid phone number",Path:"[@PATH]"}
	  `

	  replacer := strings.NewReplacer(
	  	"[@ERRVARIABLE]", c.ErrVariable(),
	  	"[@FIELD]", fieldName,
	  	"[@PATH]", fmt.Sprintf("%s.%s", c.structName, fieldName),
	  	"[@EXPRESSION]", c.expression,
	  )

	  return replacer.Replace(errTemplate)
}

func (v *phonenumberValidator) ErrVariable() string {
    return strings.ReplaceAll("Err[@PATH]PhonenumberValidation", "[@PATH]", v.structName+v.FieldName())
}

func (v *phonenumberValidator) Imports() []string {
    // Add any imports your validation logic needs
    return []string{"regexp"}
}

// ValidatePhonenumber creates a new phonenumber validator for the given field.
func ValidatePhonenumber(pass *codegen.Pass, field *ast.Field, expressions map[string]string, structName string) validator.Validator {
    typ := pass.TypesInfo.TypeOf(field.Type)

    // Type checking - ensure it's a string
    basic, ok := typ.Underlying().(*types.Basic)
    if !ok || basic.Kind() != types.String {
        return nil
    }

    validator.GeneratorMemory[fmt.Sprintf(phonenumberKey, structName+field.Names[0].Name)] = false

    // Parse pattern from expressions, default to international format
    pattern := `^\+?[1-9]\d{1,14}$`
    if p, ok := expressions["pattern"]; ok {
        pattern = p
    }

    return &phonenumberValidator{
        pass:       pass,
        field:      field,
        structName: structName,
        pattern:    pattern,
    }
}
```

### Step 3: Testing Implementation

#### A. Golden Tests (`internal/analyzers/govalid/testdata/src/phonenumber/`)

Create test input file `phonenumber.go`:

```go
package phonenumber

type User struct {
    // govalid:phonenumber
    Phone string `json:"phone"`
    
    // govalid:phonenumber,pattern=^\\d{3}-\\d{4}$
    ZipCode string `json:"zip_code"`
}
```

Create expected output file `govalid.golden`:

```go
// Code generated by govalid; DO NOT EDIT.
package phonenumber

import (
    "errors"
    "regexp"
)

var (
    ErrNilUser = errors.New("input User is nil")
    ErrUserPhonePhonenumberValidation = errors.New("field Phone must be a valid phone number")
    ErrUserZipCodePhonenumberValidation = errors.New("field ZipCode must be a valid phone number")
)

func ValidateUser(t *User) error {
    if t == nil {
        return ErrNilUser
    }
    
    if !regexp.MustCompile(`^\+?[1-9]\d{1,14}$`).MatchString(t.Phone) {
        return ErrUserPhonePhonenumberValidation
    }
    
    if !regexp.MustCompile(`^\d{3}-\d{4}$`).MatchString(t.ZipCode) {
        return ErrUserZipCodePhonenumberValidation
    }
    
    return nil
}
```

#### B. Unit Tests (`test/unit/phonenumber_test.go`)

```go
package unit

import (
    "testing"
    "github.com/sivchari/govalid/test"
)

func TestPhonenumberValidation(t *testing.T) {
    tests := []struct {
        name        string
        phone       string
        expectError bool
    }{
        {"valid_international", "+1234567890", false},
        {"valid_without_plus", "1234567890", false},
        {"invalid_empty", "", true},
        {"invalid_letters", "abc123", true},
        {"invalid_too_long", "+123456789012345678", true},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            user := &test.UserPhoneNumber{Phone: tt.phone}
            err := test.ValidateUserPhoneNumber(user)
            hasError := err != nil
            
            if hasError != tt.expectError {
                t.Errorf("expected error: %v, got error: %v (%v)", tt.expectError, hasError, err)
            }
        })
    }
}
```

#### C. Benchmark Tests (`test/benchmark/benchmark_phonenumber_test.go`)

```go
package benchmark

import (
    "testing"
    "github.com/go-playground/validator/v10"
    "github.com/sivchari/govalid/test"
)

func BenchmarkGoValidPhonenumber(b *testing.B) {
    instance := test.UserPhoneNumber{Phone: "+1234567890"}
    b.ResetTimer()
    for b.Loop() {
        err := test.ValidateUserPhoneNumber(&instance)
        if err != nil {
            b.Fatal("unexpected error:", err)
        }
    }
    b.StopTimer()
}

func BenchmarkGoPlaygroundPhonenumber(b *testing.B) {
    validate := validator.New()
    validate.RegisterValidation("phone", func(fl validator.FieldLevel) bool {
        // Simple phone validation for comparison
        return len(fl.Field().String()) >= 10
    })
    
    instance := struct {
        Phone string `validate:"phone"`
    }{Phone: "+1234567890"}
    
    b.ResetTimer()
    for b.Loop() {
        err := validate.Struct(&instance)
        if err != nil {
            b.Fatal("unexpected error:", err)
        }
    }
    b.StopTimer()
}
```

### Step 4: Test Execution and Validation

```bash
# 1. Build and install updated binary
go install ./cmd/govalid/

# 2. Generate test files
cd test && go generate

# 3. Run golden tests
cd .. && go test ./internal/analyzers/govalid/ -v

# 4. Run unit tests
cd test && go test ./unit/ -v

# 5. Run benchmarks
go test ./benchmark/ -bench=Benchmark.*Phonenumber -benchmem

# 6. Run lint checks
make golangci-lint

# 7. Update benchmark README with results
# Edit test/benchmark/README.md
```

### Step 5: Documentation Updates

Update the main README.md with your new marker:

```markdown
| `phonenumber` | Phone number validation | string | `// govalid:phonenumber` or `// govalid:phonenumber,pattern=^\d{10}$` |
```

## üéØ Key Differences from Old System

### What's Changed:

1. **No Manual Switch Statements**: The registry system automatically discovers your validator
2. **No Manual Marker Definition**: `markers_generated.go` is auto-generated
3. **Automatic Initializer Creation**: No need to manually create initializer files
4. **Single Command Integration**: `go generate` handles everything

### What Stays the Same:

1. **Validator Implementation**: Core logic remains the same
2. **Testing Approach**: Golden tests, unit tests, and benchmarks
3. **Performance Focus**: Zero-allocation design principles

## üí° Best Practices

### Performance Optimization

1. **Avoid Allocations**: Use inline comparisons when possible
2. **Precompile Regexes**: For complex patterns, consider using validation helper functions
3. **Benchmark Everything**: Always compare against go-playground/validator

### Code Quality

1. **Follow Existing Patterns**: Look at `maxlength.go` or `email.go` for examples
2. **Type Safety**: Always check field types in your Validate function
3. **Clear Error Messages**: Make errors actionable for users

### Validation Helper Functions

For complex validation logic, use external helper functions:

```go
// validation/validationhelper/phone.go
package validationhelper

import "regexp"

var phoneRegex = regexp.MustCompile(`^\+?[1-9]\d{1,14}$`)

func IsValidPhoneNumber(phone string) bool {
    return phoneRegex.MatchString(phone)
}
```

Then in your validator:
```go
func (v *phonenumberValidator) Validate() string {
    return fmt.Sprintf("!validationhelper.IsValidPhoneNumber(t.%s)", v.FieldName())
}

func (v *phonenumberValidator) Imports() []string {
    return []string{"github.com/sivchari/govalid/validation/validationhelper"}
}
```

## ‚úÖ Quality Checklist

Before submitting your pull request, ensure your contribution meets these quality standards:

### Code Quality
- [ ] Code passes `make golangci-lint` without errors
- [ ] All tests pass: `make test`
- [ ] Code follows existing patterns and conventions
- [ ] No hard-coded values (use constants or configuration)
- [ ] Error messages are clear and actionable

### Testing Requirements
- [ ] Golden tests created and passing (`internal/analyzers/govalid/testdata/`)
- [ ] Unit tests implemented with boundary value testing (`test/unit/`)
- [ ] Benchmark tests comparing against popular validation libraries (`test/benchmark/`)
  - [ ] [go-playground/validator](https://github.com/go-playground/validator) (BenchmarkGoPlayground*)
  - [ ] [asaskevich/govalidator](https://github.com/asaskevich/govalidator) (BenchmarkGoValidator*)
  - [ ] [go-ozzo/ozzo-validation](https://github.com/go-ozzo/ozzo-validation) (BenchmarkOzzoValidation*)
  - [ ] [gookit/validate](https://github.com/gookit/validate) (BenchmarkGookitValidate*)
- [ ] All test files generated: `cd test && go generate`

### Performance Standards
- [ ] Zero allocations in validation logic (verified via benchmarks)
- [ ] Performance improvement over existing validation libraries (minimum 2x faster)
- [ ] Benchmark results added to `test/benchmark/README.md`

### Documentation
- [ ] README.md updated with new marker documentation
- [ ] Code includes appropriate comments and examples
- [ ] Validator usage examples provided

### Integration
- [ ] Validator scaffold generated with `make generate-validator MARKER=yourmarker`
- [ ] Registry files automatically updated
- [ ] Binary rebuilt and installed: `go install ./cmd/govalid/`

### Final Verification
- [ ] All GitHub Actions CI checks pass
- [ ] No breaking changes to existing functionality
- [ ] Contribution follows project license requirements

## ü§ù Getting Help

- **Issues**: Check existing issues or create a new one
- **Discussions**: Use GitHub Discussions for questions
- **Examples**: Reference existing validators in `internal/validator/rules/`

## üìú License

By contributing to govalid, you agree that your contributions will be licensed under the same license as the project.
